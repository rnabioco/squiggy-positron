/**
 * Pipeline Session Detector
 *
 * Detects and loads squiggy-session.json files generated by external pipelines
 * (e.g., aa-tRNA pipeline). Pipeline sessions use paths relative to the session
 * file's location, unlike standard sessions which use absolute paths.
 */

import * as vscode from 'vscode';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as crypto from 'crypto';
import { SessionState, SampleSessionState } from '../types/squiggy-session-types';
import { PathResolver } from './path-resolver';
import { SessionStateManager } from './session-state-manager';
import { logger } from '../utils/logger';

/** Default session filename generated by pipelines */
const PIPELINE_SESSION_FILENAME = 'squiggy-session.json';

/** Workspace state key for user preference */
const PIPELINE_SESSION_PREFERENCE_KEY = 'squiggy.pipelineSessionAutoLoad';

/** User preferences for auto-load behavior */
type AutoLoadPreference = 'ask' | 'skip';

/**
 * Result of pipeline session detection
 */
export interface PipelineSessionDetectionResult {
    found: boolean;
    sessionPath?: string;
    sessionDir?: string;
    session?: SessionState;
    error?: string;
}

/**
 * Result of checksum validation
 */
export interface ChecksumValidationResult {
    valid: boolean;
    mismatches: Array<{
        filePath: string;
        expected?: string;
        actual?: string;
        reason: 'missing' | 'changed' | 'new';
    }>;
}

/**
 * Detect pipeline session file in workspace folders
 *
 * Scans all workspace folders for a squiggy-session.json file.
 * Returns the first match found.
 *
 * @returns Detection result with session path and parsed content if found
 */
export async function detectPipelineSession(): Promise<PipelineSessionDetectionResult> {
    const workspaceFolders = vscode.workspace.workspaceFolders;

    if (!workspaceFolders || workspaceFolders.length === 0) {
        return { found: false };
    }

    // Scan each workspace folder for session file
    for (const folder of workspaceFolders) {
        const sessionPath = path.join(folder.uri.fsPath, PIPELINE_SESSION_FILENAME);

        try {
            // Check if file exists
            await fs.access(sessionPath);

            // Read and parse session
            const json = await fs.readFile(sessionPath, 'utf-8');
            const session = JSON.parse(json) as SessionState;

            // Validate session schema
            const validation = SessionStateManager.validateSession(session);
            if (!validation.valid) {
                logger.warning(
                    `Pipeline session at ${sessionPath} has invalid schema: ${validation.errors.join(', ')}`
                );
                continue; // Try next workspace folder
            }

            logger.info(`Detected pipeline session at ${sessionPath}`);

            return {
                found: true,
                sessionPath,
                sessionDir: path.dirname(sessionPath),
                session,
            };
        } catch (_error) {
            // File doesn't exist or can't be read - continue to next folder
            continue;
        }
    }

    return { found: false };
}

/**
 * Resolve all relative paths in a session to absolute paths
 *
 * Pipeline sessions store paths relative to the session file's directory.
 * This function converts all paths to absolute paths for loading.
 *
 * @param session Session state with potentially relative paths
 * @param sessionFileDir Directory containing the session file
 * @returns New SessionState with all paths resolved to absolute
 */
export function resolveAllPaths(session: SessionState, sessionFileDir: string): SessionState {
    const resolvedSamples: { [sampleName: string]: SampleSessionState } = {};

    for (const [sampleName, sampleData] of Object.entries(session.samples)) {
        // Resolve POD5 paths
        const resolvedPod5Paths = sampleData.pod5Paths.map((p) =>
            PathResolver.resolveSessionRelativePath(p, sessionFileDir)
        );

        // Resolve BAM path if present
        const resolvedBamPath = sampleData.bamPath
            ? PathResolver.resolveSessionRelativePath(sampleData.bamPath, sessionFileDir)
            : undefined;

        // Resolve FASTA path if present
        const resolvedFastaPath = sampleData.fastaPath
            ? PathResolver.resolveSessionRelativePath(sampleData.fastaPath, sessionFileDir)
            : undefined;

        resolvedSamples[sampleName] = {
            pod5Paths: resolvedPod5Paths,
            bamPath: resolvedBamPath,
            fastaPath: resolvedFastaPath,
        };
    }

    // Also update fileChecksums keys to absolute paths
    let resolvedChecksums: SessionState['fileChecksums'] | undefined;
    if (session.fileChecksums) {
        resolvedChecksums = {};
        for (const [filePath, info] of Object.entries(session.fileChecksums)) {
            const resolvedPath = PathResolver.resolveSessionRelativePath(filePath, sessionFileDir);
            resolvedChecksums[resolvedPath] = info;
        }
    }

    return {
        ...session,
        samples: resolvedSamples,
        fileChecksums: resolvedChecksums,
    };
}

/**
 * Validate file checksums against stored values
 *
 * Compares MD5 checksums of files against values stored in the session.
 * Useful for detecting if files have changed since the session was exported.
 *
 * @param session Session state with fileChecksums (paths should be absolute)
 * @returns Validation result with list of mismatched files
 */
export async function validateChecksums(session: SessionState): Promise<ChecksumValidationResult> {
    const mismatches: ChecksumValidationResult['mismatches'] = [];

    if (!session.fileChecksums) {
        // No checksums stored, assume valid
        return { valid: true, mismatches: [] };
    }

    for (const [filePath, expectedInfo] of Object.entries(session.fileChecksums)) {
        try {
            // Check if file exists
            await fs.access(filePath);

            // Read file and calculate MD5
            const content = await fs.readFile(filePath);
            const hash = crypto.createHash('md5');
            hash.update(content);
            const actualMd5 = hash.digest('hex');

            // Compare checksums
            if (expectedInfo.md5 && expectedInfo.md5 !== actualMd5) {
                mismatches.push({
                    filePath,
                    expected: expectedInfo.md5,
                    actual: actualMd5,
                    reason: 'changed',
                });
            }
        } catch (_error) {
            // File doesn't exist or can't be read
            mismatches.push({
                filePath,
                expected: expectedInfo.md5,
                reason: 'missing',
            });
        }
    }

    // Check for new files in session that don't have checksums
    for (const sampleData of Object.values(session.samples)) {
        for (const pod5Path of sampleData.pod5Paths) {
            if (!session.fileChecksums[pod5Path]) {
                mismatches.push({
                    filePath: pod5Path,
                    reason: 'new',
                });
            }
        }
        if (sampleData.bamPath && !session.fileChecksums[sampleData.bamPath]) {
            mismatches.push({
                filePath: sampleData.bamPath,
                reason: 'new',
            });
        }
        if (sampleData.fastaPath && !session.fileChecksums[sampleData.fastaPath]) {
            mismatches.push({
                filePath: sampleData.fastaPath,
                reason: 'new',
            });
        }
    }

    return {
        valid: mismatches.length === 0,
        mismatches,
    };
}

/**
 * Get user's auto-load preference from global state
 *
 * @param context Extension context for accessing global state
 * @returns User's preference ('ask' or 'skip')
 */
export function getAutoLoadPreference(context: vscode.ExtensionContext): AutoLoadPreference {
    return context.globalState.get<AutoLoadPreference>(PIPELINE_SESSION_PREFERENCE_KEY, 'ask');
}

/**
 * Set user's auto-load preference in global state
 *
 * @param context Extension context for accessing global state
 * @param preference Preference to store
 */
export async function setAutoLoadPreference(
    context: vscode.ExtensionContext,
    preference: AutoLoadPreference
): Promise<void> {
    await context.globalState.update(PIPELINE_SESSION_PREFERENCE_KEY, preference);
}

/**
 * Show checksum mismatch warning to user
 *
 * @param mismatches List of files with checksum issues
 * @returns true if user wants to continue loading, false otherwise
 */
export async function showChecksumWarning(
    mismatches: ChecksumValidationResult['mismatches']
): Promise<boolean> {
    const changedFiles = mismatches.filter((m) => m.reason === 'changed');
    const missingFiles = mismatches.filter((m) => m.reason === 'missing');

    let message = 'Some files in the pipeline session have changed:\n';

    if (changedFiles.length > 0) {
        message += `\nModified files (${changedFiles.length}):\n`;
        message += changedFiles.map((m) => `  - ${path.basename(m.filePath)}`).join('\n');
    }

    if (missingFiles.length > 0) {
        message += `\nMissing files (${missingFiles.length}):\n`;
        message += missingFiles.map((m) => `  - ${path.basename(m.filePath)}`).join('\n');
    }

    message += '\n\nContinue loading anyway?';

    const response = await vscode.window.showWarningMessage(
        message,
        { modal: true },
        'Load Anyway',
        'Cancel'
    );

    return response === 'Load Anyway';
}

/**
 * Browse for a pipeline session file manually
 *
 * @returns Path to selected session file, or undefined if cancelled
 */
export async function browsePipelineSession(): Promise<string | undefined> {
    const uris = await vscode.window.showOpenDialog({
        canSelectMany: false,
        filters: {
            'Squiggy Session': ['json'],
            'All Files': ['*'],
        },
        title: 'Select Pipeline Session File',
    });

    if (!uris || uris.length === 0) {
        return undefined;
    }

    return uris[0].fsPath;
}
